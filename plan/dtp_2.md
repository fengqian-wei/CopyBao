# 数据传输协议（DTP） 0.2

该协议负责将上层数据_可靠地_从主机传输至虚拟机。

## 设计考虑

假设：

1.传输是有延迟的。延迟可以超过连续两字符的发送间隔。
2.接收方由忙变为空闲后，除非发送方再发送，否则不会再收到字符。

推论：

1.接收方由空闲变为忙，可以作为接收方收到第一个字符的标志。因此，一旦检测到接收方为忙，就能确定接收方显示的结果就有效了。
2.接收方由忙变为空闲，可以作为传输结束的标志。

错误情况：

- 可分为乱序、重复、丢失。
- 正常的错误情况是错误发生在包内。
- 丢失的特殊情况：
  - 丢失包头
  - 丢失包尾
- 乱序的特殊情况：
  - 数据先于包头到达
  - 数据落后于包尾到达
  - 包头在包尾后到达
- 重复的特殊情况：
  - 数据在包后重复（包本身没有问题）

机制：

以下机制是为了防止错误的数据包被接收，或导致接收方进入错误状态。

- 校验码：对包内数据做校验。可以拒绝内出错的数据包。需要注意的是，校验码本身也可以出错，所以如果校验码长度不够，或者包含非法字符，那么连校验都不必进行。
- 非接收状态非法字符的检测：未接收时如果接收到包头以外字符，则汇报错误。
- 超时的检测与自动复位：从忙变为空闲时，如果还处在接收状态，就汇报错误，并自动回到非接收状态。
- 结果锁定：一旦出现了结果（接收到包尾字符，校验成功或校验失败，汇报成功或错误；收到非法字符，汇报错误），马上锁定结果，同时锁死状态，直到空闲。此间即使再收到后续字符，也不改变结果。

## 格式

### 主机→虚拟机

主机通过模拟键盘输入向虚拟机发送数据，数据的发送是以**包**为单位的，包个格式如下：

```
<ABCDxxxx>
```

其中：

- <code>&lt;</code>和<code>&gt;</code>是包的分界符，标志包的开头和结尾。中间是包内容。
- <code>ABCD</code>是四位十六进制数校验码。
- <code>xxxx</code>是上层数据。

注释：

- 接收程序准备使用C#编写，打算用C#对字符串的<code>hashCode()</code>函数，对校验码之后、结尾符之前的字符串产生校验值。取该校验值十六进制表示中的四位作为校验码。
- 要求上层数据不含大小于号字符。（并不保证数据的透明传输。）

### 虚拟机→主机

![](recv_1.png)

接收程序是全屏显示的，它占用屏幕四角，显示带颜色的方块，以此向主机发送消息。初始状态下四个方块置黑。我们只使用左上角和右上角的方块。

左上角方块：

- 表示当前的**状态**。
- 红色表示忙。
- 黑色表示空闲。

右上角方块：

- 表示当前的接收**结果**。
- 黑色表示无结果。
- 红色表示接收出错。
- 绿色表示接收成功。

## 状态机

### 接收方

接收方有2个状态机。状态机1负责**忙检测**。它有两个状态：

（定义常量**TIMEOUT** = 200ms）

```
State 1: （初始状态）
	有按键输入→设置状态为【忙】，进入 State 2

State 2:
	TIMEOUT ms后→设置状态为【空闲】，进入 State 1
        代理执行 状态机2 的状态转移
    有按键输入→重置定时器，保持本状态
```

状态机2负责接收结果的显示：

```
State 1: （初始状态）（未接收状态）
	'<'键按下→设置结果为【无结果】，开启超时检测，跳到 State 2
    其他键按下→设置结果为【接收出错】，进入 State 3

State 2: （接收状态）
    状态由【忙】变为【空闲】→设置结果为【接收出错】，跳到 State 1
    '>'键按下→关闭超时检测，检查包内容，跳到 State 3
    	正确→设置结果为【接收成功】，完成相应动作
        错误→设置结果为【接收出错】
    其他键按下→收集此字符

State 3: （结果锁定状态）
    状态由【忙】变为【空闲】→跳到 State 1
    不处理按键
```

注意：上面没有考虑Esc键。在【空闲】状态下按Esc键，应退出程序。

### 发送方

发送方在发送数据前，先把封装好的数据包写到缓冲区。整个发送过程就是把缓冲区的内容刷入虚拟机的过程。

发送过程中的状态触发由一个定时器处理，每次定时器超时，就进行一次状态转移。适合当这个定时器周期的值有：<code>5, 10, 20, 50</code>。

```
State 1: （初始状态）
    对方状态为【空闲】→跳到 State 2
    否则→保持本状态

State 2:
    对方状态为【忙】 and 对方结果为【接收出错】→跳到 State 3
    缓冲区还有字符→发送该字符，保持本状态
    缓冲区为空→跳到State 3

State 3:
    对方状态为【忙】→保持本状态
    对方状态为【空闲】→
      and 对方结果为【接收成功】→调用 <取下一段数据callback>
              如果还有则跳到 State 1，否则调用 <完成callback>
      and 对方结果为其他→跳到 State 1
```
